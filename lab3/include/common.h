#ifndef COMMON_H
#define COMMON_H

#include <string>

const int EMPTY_C = 0x00;
const int KNIGHT_BIT = 0x01;
const int PRINCESS_BIT = 0x02;
const int MONSTER_BIT = 0x04;
const int EXIT_BIT = 0x08;
const int STAIR_BIT = 0x10;

typedef int RoomType;          // RoomType is a one-hot encoding of directions
typedef int RoomContent;       // RoomContent is a one-hot encoding of objects in the room
typedef std::string Command;

// Direction of movement
enum Direction {
    EAST_D, SOUTH_D, WEST_D, NORTH_D, UP_D, DOWN_D, ERROR_D
};

// Type of game status, generated by Castle class
// Designed for Game class to keep track of the game status
enum GameStatus {
    PREPARE_S, RUNNING1_S, RUNNING2_S, WIN_S, LOSE_S, QUIT_S
};

// Type of command
enum CommandType {
    MOVE_CMD, QUIT_CMD, RESTART_CMD, ERROR_CMD
};

// Data packet returned by parse_command function
struct CommandParseResult {
    CommandType type;         // type of command
    Direction direction;      // direction of movement (if go command)

    CommandParseResult(CommandType _type = ERROR_CMD, Direction _direction = ERROR_D):
        type(_type), direction(_direction) {}
};

// Basic information table of directions
const struct DirectionInfo {
    Direction direction;       // Type of direction
    int bit_mask;              // Bit mask of direction in RoomType
    std::string name;          // Name of direction
    int x_offset;
    int y_offset;
    int level_offset;
} direction_info[] = {
    {EAST_D,0x01, "east", 0, 1, 0 },
    {SOUTH_D, 0x02, "south", 1, 0, 0 },
    {WEST_D, 0x04, "west", 0, -1, 0 },
    {NORTH_D, 0x08, "north", -1, 0, 0 },
    {UP_D, 0x10, "up", 0, 0, 1 },
    {DOWN_D, 0x20, "down", 0, 0, -1 },
    {ERROR_D, 0x00, "error", 0, 0, 0 }
};

const int NUM_DIRECTIONS = sizeof(direction_info) / sizeof(direction_info[0]) - 1;

// Basic information table of rooms
// The room name is decided by the room type
const struct RoomInfo {
    RoomType room_type;          // Type of room
    std::string room_name;       // Name of room
} room_info[] = {
    {0x00, "jail"},
    {0x01, "garage"},
    {0x02, "basement"},
    {0x03, "bathroom"},
    {0x04, "bedroom"},
    {0x05, "kitchen"},
    {0x06, "attic"},
    {0x07, "gym"},
    {0x08, "library"},
    {0x09, "office"},
    {0x0A, "laundry"},
    {0x0B, "dining room"},
    {0x0C, "nursery"},
    {0x0D, "lounge"},
    {0x0E, "guest room"},
    {0x0F, "corridor"}
};

// Position describes the coordinates of a room in the castle
struct Position {
    int x;
    int y;
    int level;

    Position(int _x = 0, int _y = 0, int _level = 0): x(_x), y(_y), level(_level) {}

    bool operator == (const Position& other) {
        return x == other.x && y == other.y && level == other.level;
    }

    // @brief Get the neighbor position in the given direction
    // @param dir The direction to move to the neighbor
    // @return The neighbor position
    Position neighbor(Direction dir) {
        if (dir == ERROR_D) {  // ERROR_D is not a valid direction
            return *this;
        } else {
            return Position(
                x + direction_info[dir].x_offset, 
                y + direction_info[dir].y_offset, 
            level + direction_info[dir].level_offset
            );
        }
    }

    // @brief Update the position by moving to the neighbor in the given direction
    // @param dir The direction to move to the neighbor
    void go_neighbor(Direction dir) {
        if (dir != ERROR_D) {
            x += direction_info[dir].x_offset;
            y += direction_info[dir].y_offset;
            level += direction_info[dir].level_offset;
        }
    }
};

// Room describes the properties of a room in the castle
struct Room {
    RoomType type;             // Type of room, determined by the exits in the room
    RoomContent content;       // Content of room
    Position pos;              // Coordinates of room in the castle
    
    Room(RoomType _type = 0, RoomContent _content = EMPTY_C, Position _pos = Position()):
        type(_type), content(_content), pos(_pos) {}
    
    Room(const Room& other):
        type(other.type), content(other.content), pos(other.pos) {}
    
    // @brief Add an exit to the room
    // @param dir The direction of the exit to add
    void add_direction(Direction dir) {
        if (dir != ERROR_D) {
            type |= 1 << dir;
        }
    }

    // @brief Remove an exit from the room
    // @param dir The direction of the exit to remove
    bool has_direction(Direction dir) {
        return type & (1 << dir);
    }

    // @brief Add content to the room
    // @param new_content The content to add to the room
    void add_content(RoomContent new_content) {
        content |= new_content;
    }

    // @brief Remove content from the room
    // @param removed_content The content to remove from the room
    void remove_content(RoomContent removed_content) {
        content &= ~removed_content;
    }
};

#endif